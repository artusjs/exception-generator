import 'reflect-metadata'
import {ExceptionItem, Scanner} from '@artus/core'
import {Command, Flags} from '@oclif/core'
import path from 'node:path'
import 'ts-node/register'
import {mkdir, unlink, writeFile} from 'node:fs/promises'
import {toLowerCamelCase, toUpperCamelCase} from '../utils'

export interface ErrorCodeItem {
  code: string;
  className: string;
}

const errorClassTemplate = (codeItem: ErrorCodeItem) =>
  `export class ${codeItem.className} extends ArtusStdError {
  static code = '${codeItem.code}';
  name = '${codeItem.className}';
  constructor() {
    super(${codeItem.className}.code);
  }
}
`

export default class Generate extends Command {
  static description = 'describe the command here'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
  ]

  static flags = {
    outputDir: Flags.string({
      char: 'o',
      description: 'directory to output',
      default: './exception',
    }),
    configDir: Flags.string({
      char: 'c',
      description: 'directory to store config',
      default: 'config',
    }),
    postfix: Flags.string({
      description: 'add to the end of all class name',
      default: 'Error',
    }),
    force: Flags.boolean({
      char: 'f',
      description: 'will remove output dir before generate',
      default: false,
    }),
  }

  static args = [{
    name: 'projectDir',
    default: '.',
  }]

  private resolvePath(val: string): string {
    return path.resolve(process.cwd(), val)
  }

  public async run(): Promise<void> {
    const {args, flags} = await this.parse(Generate)

    const projectDir = this.resolvePath(args.projectDir)
    const configDir = flags.configDir
    const outputDir = this.resolvePath(flags.outputDir)
    const postfix = flags.postfix
    const force = flags.force

    if (force) {
      await unlink(outputDir)
    }

    await mkdir(outputDir, {
      recursive: true,
    })

    const scanner = new Scanner({
      configDir,
      loaderListGenerator: () => ['exception'],
      extensions: ['.ts', '.js', '.json'],
    })
    const codeMap: Record<string, ErrorCodeItem[]> = {}
    try {
      const manifestMap = await scanner.scan(projectDir)
      for (const manifest of Object.values(manifestMap)) {
        for (const manifestItem of manifest.items) {
          const exceptionMap: Record<string, ExceptionItem> = require(path.resolve(projectDir, manifestItem.path + '.json'))
          const codeList = Object.keys(exceptionMap)
          for (const code of codeList) {
            const [originalNamespace, originalCode] = code.split(':')
            const className = toUpperCamelCase(originalCode) + postfix
            const namespace = toLowerCamelCase(originalNamespace)
            codeMap[namespace] = codeMap[namespace] ?? []
            codeMap[namespace].push({
              code,
              className,
            })
          }
        }
      }

      const result: Promise<void>[] = []
      for (const [namespace, codeItemList] of Object.entries(codeMap)) {
        let content = '// THIS FILE IS AUTO-GENERATED BY ARTUS EXCEPTION GENERATOR\n'
        content += 'import { ArtusStdError } from \'@artus/core\';\n\n'
        content += codeItemList.map(item => errorClassTemplate(item)).join('\n')
        result.push(writeFile(path.resolve(outputDir, `${namespace}.ts`), content))
      }

      await Promise.all(result)
    } catch (error) {
      console.error(error)
    }
  }
}
